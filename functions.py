def master_list():
    kleuren = ["R", "B", "G", "Y"]
    master_lst = []

    for R in range(len(kleuren)):
        for B in range(len(kleuren)):
            for G in range(len(kleuren)):
                for Y in range(len(kleuren)):
                    master_lst.append([kleuren[R], kleuren[B], kleuren[G], kleuren[Y]])
    return master_lst

# ======================================================================================================================

def secret_code_generator():
    import random
    return random.choice(master_list())

# ======================================================================================================================
# This function allows the player to input a random_guess that gets checked by the system.

def random_guess():
    x = input("Please give your combination of the following -> [R B G Y]: ")
    y = x.upper()
    z = [word for line in y for word in line.split()]
    if len(z) != 4:
        print("ERROR: Length of code is not valid. Please try again.")
    return z

# ======================================================================================================================
# This function works as the input of code when the player has to think of a secret_code to play against the system.

def user_secret_code():
    x = input("What will the secret code be? Use the following characters in a random order. [R B G Y]: ")
    y = x.upper()
    z = [word for line in y for word in line.split()]
    if len(z) != 4:
        print("ERROR: Length of code is not valid. Please try again.")
    return z

# ======================================================================================================================
# This function is used to translate the two lists and compare them to each other, to give feedback in the form of (x,y)

def beoordelingsfunctie(x, y):
    black_pin = 0
    white_pin = 0
    temporary_lst = []

    for i in range(len(x)):
        temporary_lst.append(x[i])

        if y[i] == x[i]:
            black_pin += 1
            temporary_lst.remove(x[i])

    for i in range(len(x)):
        if y[i] in temporary_lst:
            temporary_lst.remove(y[i])
            white_pin += 1

    return black_pin, white_pin

# ======================================================================================================================
# The first algorithm that focuses on consistency between two random guesses generated by different functions.

def simple_algorithm():
    secret_code = user_secret_code()

    while len(master_list()) > 1:
        random_code = secret_code_generator()

        first_assessment = (beoordelingsfunctie(x=secret_code, y=random_code))

        if first_assessment == (4, 0):
            print("Congratulations! The secret code:", random_code, "has been found!")
            break

        for i in range(len(master_list())):
            random_code_2 = secret_code_generator()

            second_assessment = (beoordelingsfunctie(x=random_code, y=random_code_2))

            if first_assessment != second_assessment:
                master_list().remove(random_code_2)
    return

# ======================================================================================================================
# A function I created to help myself find some indexes for clarity's sake

def finding_index(x):

    for i in range(len(master_list())):
        if master_list()[i] == x:
            return i

# ======================================================================================================================
# This function takes a specific set of values in the master_lst and puts them in a separate list to put them through
# the worst_case_algorithm. These values are the 'AABB' combinations which are the elements with the smallest partition
# value

def worst_case_guess():
    import random
    worst_case_lst = []
    for i in master_list():
        if i[0] == i[1] and i[2] == i[3]:
            worst_case_lst.append(i)
    for i in worst_case_lst:
        if i[0] == i[1] and i[1] == i[2] and i[2] == i[3]:
            worst_case_lst.remove(i)

    worst_case_attempt = random.choice(worst_case_lst)
    return worst_case_attempt

# ======================================================================================================================
# The second algorithm that is derived from the worst case strategy by Knuth (1976 -1977), same format as the first
# algorithm, however this one makes use of a extra function, the worst_case_guess.


def worst_case_algorithm():
    secret_code = user_secret_code()
    efficient_code = worst_case_guess()
    print("The worst case strategy tells us that", efficient_code, "is the safest first choice!")
    null_assessment = (beoordelingsfunctie(x=secret_code, y=efficient_code))
    print("The worst case strategy gives us", null_assessment, "as feedback.")

    while len(master_list()) > 1:
        random_code = secret_code_generator()

        first_assessment = (beoordelingsfunctie(x=secret_code, y=random_code))

        if first_assessment == (4, 0):
            print("Success! The secret code:", random_code, "has been found!")
            break

        for i in range(len(master_list())):
            random_code_2 = secret_code_generator()

            second_assessment = (beoordelingsfunctie(x=random_code, y=random_code_2))

            if first_assessment != second_assessment:
                master_list().remove(random_code_2)
    return
# ======================================================================================================================

def unique_guess():
    unique_lst = []
    for i in master_list():
        if i[0] == i[1] and i[1] == i[2] and i[2] == i[3]:
            unique_lst.append(i)
    return unique_lst

# ======================================================================================================================
# This guess is based on my own play-style. I personally like using AAAA, BBBB, CCCC,
# DDDD in consecutive order, and with that information I can deduce what my next move should be.

def unique_algorithm():
    secret_code = user_secret_code()
    x = unique_guess()
    unique_code_1 = x[0]

    unique_assessment_1 = (beoordelingsfunctie(x=secret_code, y=unique_code_1))
    print("The unique strategy tells us that", unique_code_1, "is a good first choice! Feedback van", unique_code_1,
          "is", unique_assessment_1)

    unique_code_2 = x[1]
    unique_assessment_2 = (beoordelingsfunctie(x=secret_code, y=unique_code_2))
    print("The unique strategy tells us that", unique_code_2, "is a good second choice! Feedback van", unique_code_2,
          "is", unique_assessment_2)

    unique_code_3 = x[2]
    unique_assessment_3 = (beoordelingsfunctie(x=secret_code, y=unique_code_3))
    print("The unique strategy tells us that", unique_code_3, "is a good third choice! Feedback van", unique_code_3,
          "is", unique_assessment_3)

    unique_code_4 = x[3]
    unique_assessment_4 = (beoordelingsfunctie(x=secret_code, y=unique_code_4))
    print("The unique strategy tells us that", unique_code_4, "is a good fourth choice! Feedback van", unique_code_4, "is", unique_assessment_4)

    while len(master_list()) > 1:
        random_code = secret_code_generator()

        first_assessment = (beoordelingsfunctie(x=secret_code, y=random_code))

        if first_assessment == (4, 0):
            print("Success! The secret code:", random_code, "has been found!")
            break

        for i in range(len(master_list())):
            random_code_2 = secret_code_generator()

            second_assessment = (beoordelingsfunctie(x=random_code, y=random_code_2))

            if first_assessment != second_assessment:
                master_list().remove(random_code_2)
    return
